using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

/*  This Script needs to be attached to the main Camera.
*   It is going to create a Grid of Cells in a certain radius around the Camera
*   Those Cells are special Plane GameObjects with a size given by the GlobalInformation Class
*   The script will make sure that the Cells wont collide but will have a distance of exactly zero to each other
*/

public class GridGeneratorAlternative : MonoBehaviour
{

    public GameObject cell;
    private GameObject grid;
    public GameObject area;
    private GameObject terrain;
    private bool terrainGiven = true;
    private bool initialized;
    private int viewDistance;
    public int density;
    private float areaLength;
    private float areaWidth;

    public float maxBuildingHeigth;
    public float maxBuildingWidth;
    public float maxBuildingLength;
    public float minBuildingHeigth;
    public float minBuildingWidth;
    public float minBuildingLength;



    //Debugging
    private int globalIterations;
    private int localIterations;
    //------

    public void Start()
    {
        Debug.Log(area.name);
        areaLength = get2DBounds(area).x;
        areaWidth = get2DBounds(area).y;

        viewDistance = giAlternative.viewDistance;
        terrain = giAlternative.Terrain;
        grid = giAlternative.Grid;        


        if (area)  //If area is not Null
        {
            Debug.Log("Terrain found, \nfilling Terrain...");
            fillTerrain(cell, grid, area);
        }
        else
        {
            terrainGiven = false;
            //generateChunk(chunkIterations, edgelength, new Vector3(transform.position.x,0,transform.position.z), grid.transform);
        }
        initialized = true;
    }

    // Update is called once per frame
    void Update()
    {
        if (initialized)
        {
            if (!terrainGiven)
            {
                //Debugging
                //globalIterations++;
                //foreach (Vector3 item in allGenerated) {
                //    Debug.LogWarning(item);
                //}
                //----------

                //List<Vector3>[] temp = realTimeGeneration(recentlyGenerated, allGenerated);
                //recentlyGenerated = temp[0];
                //allGenerated = temp[1];
            }
        }
    }

    //Realtime Generation Algorithm
    //---------------------------
    //
    //This algorithm should be first started with a set size of 1. it then loops around the position in a Rhombus
    //The Top down functionality of this algorithm is sketched out in the following:
    //
    //The numbers represent the order of computation
    //
    //           5
    //
    //      8    1    6
    //
    // 20   4    0    2  10
    //
    //      16   3   11
    //
    //          15
    //
    //----------------------
    /*List<Vector3>[] realTimeGeneration(List<Vector3> oldGenerated, List<Vector3> allGeneratedLocal)
    {
        List<Vector3> newGenerated = new List<Vector3>();

        //Debugging--------
        localIterations = 0;
        //-----------------

        //do the following for the outer edges of the Rhombus
        foreach (Vector3 pos in oldGenerated)
        {
            localIterations++;
            Debug.Log("computing chunkLocations for: " + pos);

            //compute possible chunkLocations
            Vector3 north = new Vector3(pos.x + chunkSize, 0, pos.z);
            Vector3 east = new Vector3(pos.x, 0, pos.z - chunkSize);
            Vector3 south = new Vector3(pos.x - chunkSize, 0, pos.z);
            Vector3 west = new Vector3(pos.x, 0, pos.z + chunkSize);

            newGenerated.Add(north);
            newGenerated.Add(east);
            newGenerated.Add(south);
            newGenerated.Add(west);

            //Debugging--------
            Debug.Log(north + " was added because its north of " + pos);
            Debug.Log(east + " was added because its east of " + pos);
            Debug.Log(south + " was added because its south of " + pos);
            Debug.Log(west + " was added because its west of " + pos);

            foreach (Vector3 item in newGenerated)
            {
                Debug.Log(item + " is in newGenerated by iteration: " + globalIterations + "." + localIterations);
            }
            Debug.LogWarning("The following list is for iteration: " + globalIterations + "." + localIterations);
            foreach (Vector3 item in allGeneratedLocal)
            {
                Debug.Log(item + " is in allGenerated");
            }
            Debug.LogWarning("Listing is finished");
            //-----------------

            foreach (Vector3 item in allGeneratedLocal)
            {
                if (north == item || Vector3.Distance(globalInformation.position, north) > viewDistance)
                {
                    north = Vector3.one;
                }
                if (east == item || Vector3.Distance(globalInformation.position, east) > viewDistance)
                {
                    west = Vector3.one;
                }
                if (south == item || Vector3.Distance(globalInformation.position, south) > viewDistance)
                {
                    south = Vector3.one;
                }
                if (west == item || Vector3.Distance(globalInformation.position, west) > viewDistance)
                {
                    west = Vector3.one;
                }
            }

            if (north != Vector3.one)
            {
                allGeneratedLocal.Add(north);
                allGeneratedSize++;
                generateChunk(north, grid.transform, density);
            }
            if (east != Vector3.one)
            {
                allGeneratedLocal.Add(east);
                generateChunk(east, grid.transform, density);
                allGeneratedSize++;
            }
            if (south != Vector3.one)
            {
                allGeneratedLocal.Add(south);
                generateChunk(south, grid.transform, density);
                allGeneratedSize++;
            }
            if (west != Vector3.one)
            {

                allGeneratedLocal.Add(west);
                generateChunk(west, grid.transform, density);
                allGeneratedSize++;
            }
            //Debugging--------------
            if (allGeneratedSize >= 10)
            {
                Debug.Break();
            }
            //-----------------------
            globalInformation.chunksTotal = allGeneratedSize;
        }

        List<Vector3>[] returnValues = new List<Vector3>[2];
        returnValues[0] = newGenerated;
        returnValues[1] = allGeneratedLocal;

        return returnValues;
    }*/

    void fillTerrain(GameObject cell, GameObject grid, GameObject area)
    {
        float rangeX = areaLength;
        float rangeZ = areaWidth;
        GameObject spawned;

        for (int i = 0; i < density; i++)
        {
            float xPos = Random.Range(0, rangeX);
            float zPos = Random.Range(0, rangeZ);
            Vector3 spawnPos = new Vector3(area.transform.position.x + xPos, 0, area.transform.position.z + zPos);
            spawned = Instantiate(cell, spawnPos, Quaternion.identity);
            spawned.name = (cell.name + spawnPos);
            spawned.transform.parent = grid.transform;
            spawned.GetComponent<CellAlternative>().Initialise(this);
            globalInformation.cellsTotal++;
        }
        //grid.transform.parent = terrain.transform;
    }

    int hash(int key)
    {
        key += ~(key << 15);
        key ^= (key >> 10);
        key += (key << 3);
        key ^= (key >> 6);
        key += ~(key << 11);
        key ^= (key >> 16);
        return key;
    }

    GameObject getGridCell(GameObject obj)
    {
        Debug.Log(obj.name);
        if (obj.tag == "GridCell")
        {
            return obj;
        }
        else
        {
            return getGridCell(obj.transform.parent.gameObject);
        }
    }

    public static Vector2 get2DBounds(GameObject obj)
    {
        Bounds bounds = obj.GetComponent<MeshFilter>().sharedMesh.bounds;
        return new Vector2(obj.transform.localScale.x * bounds.size.x, obj.transform.localScale.z * bounds.size.z);
    }
}
